{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Workflow Execution Benchmark Suite","text":"<p>:warning: This repository is currently under development.</p> <p>Workflows benchmark suite for task-based execution frameworks.</p>"},{"location":"get-started/","title":"Quick Start","text":"<p>The Workflow Execution Benchmark Suite (WEBS) provides a set of standard computational workflows that can be executed with a variety of execution engines.</p>"},{"location":"get-started/#installation","title":"Installation","text":"<pre><code>git clone https://github.com/proxystore/webs\ncd webs\npython -m venv venv\n. venv/bin/activate\npip install -e .\n</code></pre> <p>Documentation on installing for local development is provided in Contributing.</p>"},{"location":"get-started/#usage","title":"Usage","text":"<pre><code>python -m webs.run {workflow-name} {args}\n</code></pre>"},{"location":"api/","title":"webs","text":"<code>webs/__init__.py</code> <p>Workflows benchmark package.</p>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>webs</li> <li>webs.config</li> <li>webs.context</li> <li>webs.data</li> <li>webs.executor<ul> <li>config</li> <li>dag</li> <li>globus</li> <li>python</li> <li>workflow</li> </ul> </li> <li>webs.logging</li> <li>webs.run<ul> <li>config</li> <li>main</li> </ul> </li> <li>webs.wf<ul> <li>synthetic<ul> <li>config</li> <li>workflow</li> </ul> </li> </ul> </li> <li>webs.workflow</li> </ul>"},{"location":"api/config/","title":"webs.config","text":"<code>webs/config.py</code>"},{"location":"api/config/#webs.config.Config","title":"Config","text":"<p>             Bases: <code>BaseModel</code></p> <p>Base configuration model type.</p>"},{"location":"api/config/#webs.config.Config.add_argument_group","title":"add_argument_group()  <code>classmethod</code>","text":"<pre><code>add_argument_group(\n    parser: ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True\n) -&gt; None\n</code></pre> <p>Add model fields as arguments of an argument group on the parser.</p> <p>Parameters:</p> <ul> <li> <code>parser</code>             (<code>ArgumentParser</code>)         \u2013          <p>Parser to add a new argument group to.</p> </li> <li> <code>argv</code>             (<code>Sequence[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional sequence of string arguments.</p> </li> <li> <code>required</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Mark arguments without defaults as required.</p> </li> </ul> Source code in <code>webs/config.py</code> <pre><code>@classmethod\ndef add_argument_group(\n    cls,\n    parser: argparse.ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Add model fields as arguments of an argument group on the parser.\n\n    Args:\n        parser: Parser to add a new argument group to.\n        argv: Optional sequence of string arguments.\n        required: Mark arguments without defaults as required.\n    \"\"\"\n    group = parser.add_argument_group(cls.__name__)\n    for field_name, field_info in cls.model_fields.items():\n        arg_name = field_name.replace('_', '-').lower()\n        group.add_argument(\n            f'--{arg_name}',\n            dest=field_name,\n            # type=field_info.annotation,\n            default=field_info.get_default(),\n            required=field_info.is_required() and required,\n            help=field_info.description,\n        )\n</code></pre>"},{"location":"api/context/","title":"webs.context","text":"<code>webs/context.py</code>"},{"location":"api/context/#webs.context.ContextManagerAddIn","title":"ContextManagerAddIn","text":"<pre><code>ContextManagerAddIn(\n    managers: (\n        Sequence[AbstractContextManager[Any] | None] | None\n    ) = None,\n)\n</code></pre> <p>Context manager add in class.</p> Source code in <code>webs/context.py</code> <pre><code>def __init__(\n    self,\n    managers: Sequence[AbstractContextManager[Any] | None] | None = None,\n) -&gt; None:\n    self._managers = [] if managers is None else managers\n</code></pre>"},{"location":"api/data/","title":"webs.data","text":"<code>webs/data.py</code>"},{"location":"api/data/#webs.data.randbytes","title":"randbytes()","text":"<pre><code>randbytes(size: int) -&gt; bytes\n</code></pre> <p>Get random byte string of specified size.</p> <p>Uses <code>random.randbytes()</code> in Python 3.9 or newer and <code>os.urandom()</code> in Python 3.8 and older.</p> <p>Parameters:</p> <ul> <li> <code>size</code>             (<code>int</code>)         \u2013          <p>size of byte string to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>         \u2013          <p>random byte string.</p> </li> </ul> Source code in <code>webs/data.py</code> <pre><code>def randbytes(size: int) -&gt; bytes:\n    \"\"\"Get random byte string of specified size.\n\n    Uses `random.randbytes()` in Python 3.9 or newer and\n    `os.urandom()` in Python 3.8 and older.\n\n    Args:\n        size (int): size of byte string to return.\n\n    Returns:\n        random byte string.\n    \"\"\"\n    max_bytes = int(1e9)\n    if sys.version_info &gt;= (3, 9) and size &lt; max_bytes:  # pragma: &gt;=3.9 cover\n        return random.randbytes(size)\n    else:  # pragma: &lt;3.9 cover\n        return os.urandom(size)\n</code></pre>"},{"location":"api/logging/","title":"webs.logging","text":"<code>webs/logging.py</code>"},{"location":"api/logging/#webs.logging.init_logging","title":"init_logging()","text":"<pre><code>init_logging(\n    logfile: Path | None = None,\n    level: int | str = logging.INFO,\n    logfile_level: int | str = logging.INFO,\n    force: bool = False,\n) -&gt; None\n</code></pre> <p>Initialize logging with custom formats.</p> <p>Adds a custom log levels RUN and WORK which are higher than INFO and lower than WARNING. RUN is used by the workflow benchmark harness and WORK is using within the workflows.</p> Usage <p>logger = init_logger(...) logger.log(RUN_LOG_LEVEL, 'message')</p> <p>Parameters:</p> <ul> <li> <code>logfile</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>option filepath to write log to (default: None).</p> </li> <li> <code>level</code>             (<code>(int, str)</code>, default:                 <code>INFO</code> )         \u2013          <p>minimum logging level (default: INFO).</p> </li> <li> <code>logfile_level</code>             (<code>(int, str)</code>, default:                 <code>INFO</code> )         \u2013          <p>minimum logging level for the logfile (default: INFO).</p> </li> <li> <code>force</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>remove any existing handlers attached to the root handler. This option is useful to silencing the third-party package logging. Note: should not be set when running inside pytest (default: False).</p> </li> </ul> Source code in <code>webs/logging.py</code> <pre><code>def init_logging(\n    logfile: pathlib.Path | None = None,\n    level: int | str = logging.INFO,\n    logfile_level: int | str = logging.INFO,\n    force: bool = False,\n) -&gt; None:\n    \"\"\"Initialize logging with custom formats.\n\n    Adds a custom log levels RUN and WORK which are higher than INFO and\n    lower than WARNING. RUN is used by the workflow benchmark harness\n    and WORK is using within the workflows.\n\n    Usage:\n        &gt;&gt;&gt; logger = init_logger(...)\n        &gt;&gt;&gt; logger.log(RUN_LOG_LEVEL, 'message')\n\n    Args:\n        logfile (str): option filepath to write log to (default: None).\n        level (int, str): minimum logging level (default: INFO).\n        logfile_level (int, str): minimum logging level for the logfile\n            (default: INFO).\n        force (bool): remove any existing handlers attached to the root\n            handler. This option is useful to silencing the third-party\n            package logging. Note: should not be set when running inside\n            pytest (default: False).\n    \"\"\"\n    logging.addLevelName(RUN_LOG_LEVEL, 'RUN')\n    logging.addLevelName(WORK_LOG_LEVEL, 'WORK')\n\n    stdout_handler = logging.StreamHandler(sys.stdout)\n    stdout_handler.setLevel(level)\n\n    handlers: list[logging.Handler] = [stdout_handler]\n    if logfile is not None:\n        logfile.parent.mkdir(parents=True, exist_ok=True)\n        handler = logging.FileHandler(logfile)\n        handler.setLevel(logfile_level)\n        handlers.append(handler)\n\n    kwargs: dict[str, Any] = {}\n    if force:  # pragma: no cover\n        kwargs['force'] = force\n\n    logging.basicConfig(\n        format=(\n            '[%(asctime)s.%(msecs)03d] %(levelname)-5s (%(name)s) :: '\n            '%(message)s'\n        ),\n        datefmt='%Y-%m-%d %H:%M:%S',\n        level=logging.DEBUG,\n        handlers=handlers,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/workflow/","title":"webs.workflow","text":"<code>webs/workflow.py</code>"},{"location":"api/workflow/#webs.workflow.Workflow","title":"Workflow","text":"<p>             Bases: <code>Protocol[WorkflowConfigT]</code></p> <p>Workflow protocol.</p> <p>Attributes:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the workflow.</p> </li> <li> <code>config_type</code>             (<code>type[WorkflowConfigT]</code>)         \u2013          <p>Workflow configuration type.</p> </li> </ul>"},{"location":"api/workflow/#webs.workflow.Workflow.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: WorkflowConfigT) -&gt; Self\n</code></pre> <p>Initialize a workflow instance from a config.</p> Source code in <code>webs/workflow.py</code> <pre><code>@classmethod\ndef from_config(cls, config: WorkflowConfigT) -&gt; Self:\n    \"\"\"Initialize a workflow instance from a config.\"\"\"\n    ...\n</code></pre>"},{"location":"api/workflow/#webs.workflow.Workflow.run","title":"run()","text":"<pre><code>run(executor: WorkflowExecutor, run_dir: Path) -&gt; None\n</code></pre> <p>Run the workflow.</p> Source code in <code>webs/workflow.py</code> <pre><code>def run(\n    self,\n    executor: WorkflowExecutor,\n    run_dir: pathlib.Path,\n) -&gt; None:\n    \"\"\"Run the workflow.\"\"\"\n    ...\n</code></pre>"},{"location":"api/executor/","title":"webs.executor","text":"<code>webs/executor/__init__.py</code>"},{"location":"api/executor/config/","title":"webs.executor.config","text":"<code>webs/executor/config.py</code>"},{"location":"api/executor/config/#webs.executor.config.ExecutorConfig","title":"ExecutorConfig","text":"<p>             Bases: <code>Config</code>, <code>ABC</code></p> <p>Executor configuration abstract base class.</p>"},{"location":"api/executor/config/#webs.executor.config.ExecutorConfig.add_argument_group","title":"add_argument_group()  <code>classmethod</code>","text":"<pre><code>add_argument_group(\n    parser: ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True\n) -&gt; None\n</code></pre> <p>Add model fields as arguments of an argument group on the parser.</p> <p>Parameters:</p> <ul> <li> <code>parser</code>             (<code>ArgumentParser</code>)         \u2013          <p>Parser to add a new argument group to.</p> </li> <li> <code>argv</code>             (<code>Sequence[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional sequence of string arguments.</p> </li> <li> <code>required</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Mark arguments without defaults as required.</p> </li> </ul> Source code in <code>webs/config.py</code> <pre><code>@classmethod\ndef add_argument_group(\n    cls,\n    parser: argparse.ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Add model fields as arguments of an argument group on the parser.\n\n    Args:\n        parser: Parser to add a new argument group to.\n        argv: Optional sequence of string arguments.\n        required: Mark arguments without defaults as required.\n    \"\"\"\n    group = parser.add_argument_group(cls.__name__)\n    for field_name, field_info in cls.model_fields.items():\n        arg_name = field_name.replace('_', '-').lower()\n        group.add_argument(\n            f'--{arg_name}',\n            dest=field_name,\n            # type=field_info.annotation,\n            default=field_info.get_default(),\n            required=field_info.is_required() and required,\n            help=field_info.description,\n        )\n</code></pre>"},{"location":"api/executor/config/#webs.executor.config.ExecutorConfig.get_executor","title":"get_executor()  <code>abstractmethod</code>","text":"<pre><code>get_executor() -&gt; Executor\n</code></pre> <p>Create an executor instance from the config.</p> Source code in <code>webs/executor/config.py</code> <pre><code>@abc.abstractmethod\ndef get_executor(self) -&gt; Executor:\n    \"\"\"Create an executor instance from the config.\"\"\"\n    ...\n</code></pre>"},{"location":"api/executor/config/#webs.executor.config.ExecutorChoicesConfig","title":"ExecutorChoicesConfig","text":"<p>             Bases: <code>Config</code></p> <p>Executor choice configuration.</p>"},{"location":"api/executor/config/#webs.executor.config.ExecutorChoicesConfig.add_argument_group","title":"add_argument_group()  <code>classmethod</code>","text":"<pre><code>add_argument_group(\n    parser: ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True\n) -&gt; None\n</code></pre> <p>Add model fields as arguments of an argument group on the parser.</p> <p>Parameters:</p> <ul> <li> <code>parser</code>             (<code>ArgumentParser</code>)         \u2013          <p>Parser to add a new argument group to.</p> </li> <li> <code>argv</code>             (<code>Sequence[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional sequence of string arguments.</p> </li> <li> <code>required</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Mark arguments without defaults as required.</p> </li> </ul> Source code in <code>webs/executor/config.py</code> <pre><code>@classmethod\ndef add_argument_group(\n    cls,\n    parser: argparse.ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Add model fields as arguments of an argument group on the parser.\n\n    Args:\n        parser: Parser to add a new argument group to.\n        argv: Optional sequence of string arguments.\n        required: Mark arguments without defaults as required.\n    \"\"\"\n    configs = get_registered()\n\n    group = parser.add_argument_group(cls.__name__)\n    group.add_argument(\n        '--executor',\n        choices=sorted(configs.keys()),\n        required=required,\n        help='executor to use',\n    )\n\n    executor_type: str | None = None\n    if argv is not None and '--executor' in argv:\n        executor_type = argv[argv.index('--executor') + 1]\n\n    for name, config_type in configs.items():\n        config_type.add_argument_group(\n            parser,\n            argv=argv,\n            required=name == executor_type,\n        )\n</code></pre>"},{"location":"api/executor/dag/","title":"webs.executor.dag","text":"<code>webs/executor/dag.py</code>"},{"location":"api/executor/dag/#webs.executor.dag.DAGExecutor","title":"DAGExecutor","text":"<pre><code>DAGExecutor(executor: Executor)\n</code></pre> <p>             Bases: <code>Executor</code></p> <p>Executor wrapper that adds DAG-like features.</p> <p>An <code>Executor</code> implementation that wraps another executor with logic for delaying task submission until all <code>Future</code> instances which are args or kwargs of a task have completed. In other words, child tasks will not be scheduled until the results of the child's parent tasks are available.</p> <p>Parameters:</p> <ul> <li> <code>executor</code>             (<code>Executor</code>)         \u2013          <p>Executor to wrap.</p> </li> </ul> Source code in <code>webs/executor/dag.py</code> <pre><code>def __init__(self, executor: Executor) -&gt; None:\n    self.executor = executor\n    self._tasks: dict[Future[Any], _Task[Any, Any]] = {}\n</code></pre>"},{"location":"api/executor/dag/#webs.executor.dag.DAGExecutor.submit","title":"submit()","text":"<pre><code>submit(\n    function: Callable[P, T],\n    /,\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; Future[T]\n</code></pre> <p>Schedule the callable to be executed.</p> <p>Parameters:</p> <ul> <li> <code>function</code>             (<code>Callable[P, T]</code>)         \u2013          <p>Callable to execute.</p> </li> <li> <code>args</code>             (<code>args</code>, default:                 <code>()</code> )         \u2013          <p>Positional arguments.</p> </li> <li> <code>kwargs</code>             (<code>kwargs</code>, default:                 <code>{}</code> )         \u2013          <p>Keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Future[T]</code>         \u2013          <p><code>Future</code> object representing the             result of the execution of the callable.</p> </li> </ul> Source code in <code>webs/executor/dag.py</code> <pre><code>def submit(\n    self,\n    function: Callable[P, T],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Future[T]:\n    \"\"\"Schedule the callable to be executed.\n\n    Args:\n        function: Callable to execute.\n        args: Positional arguments.\n        kwargs: Keyword arguments.\n\n    Returns:\n        [`Future`][concurrent.futures.Future] object representing the \\\n        result of the execution of the callable.\n    \"\"\"\n    client_future: Future[T] = Future()\n    task = _Task(self.executor, function, args, kwargs, client_future)\n    self._tasks[client_future] = task\n    client_future.add_done_callback(self._task_future_callback)\n    return client_future\n</code></pre>"},{"location":"api/executor/dag/#webs.executor.dag.DAGExecutor.map","title":"map()","text":"<pre><code>map(\n    function: Callable[P, T],\n    *iterables: Iterable[args],\n    timeout: float | None = None,\n    chunksize: int = 1\n) -&gt; Iterator[T]\n</code></pre> <p>Map a function onto iterables of arguments.</p> <p>Parameters:</p> <ul> <li> <code>function</code>             (<code>Callable[P, T]</code>)         \u2013          <p>A callable that will take as many arguments as there are passed iterables.</p> </li> <li> <code>iterables</code>             (<code>Iterable[args]</code>, default:                 <code>()</code> )         \u2013          <p>Variable number of iterables.</p> </li> <li> <code>timeout</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>The maximum number of seconds to wait. If None, then there is no limit on the wait time.</p> </li> <li> <code>chunksize</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>If greater than one, the iterables will be chopped into chunks of size chunksize and submitted to the executor. If set to one, the items in the list will be sent one at a time.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[T]</code>         \u2013          <p>An iterator equivalent to: <code>map(func, *iterables)</code> but the calls             may be evaluated out-of-order.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>if chunksize is less than one.</p> </li> </ul> Source code in <code>webs/executor/dag.py</code> <pre><code>def map(\n    self,\n    function: Callable[P, T],\n    *iterables: Iterable[P.args],\n    timeout: float | None = None,\n    chunksize: int = 1,\n) -&gt; Iterator[T]:\n    \"\"\"Map a function onto iterables of arguments.\n\n    Args:\n        function: A callable that will take as many arguments as there are\n            passed iterables.\n        iterables: Variable number of iterables.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n        chunksize: If greater than one, the iterables will be chopped into\n            chunks of size chunksize and submitted to the executor. If set\n            to one, the items in the list will be sent one at a time.\n\n    Returns:\n        An iterator equivalent to: `map(func, *iterables)` but the calls \\\n        may be evaluated out-of-order.\n\n    Raises:\n        ValueError: if chunksize is less than one.\n    \"\"\"\n    # Based on concurrent.futures.ProcessPoolExecutor.map()\n    # https://github.com/python/cpython/blob/37959e25cbbe1d207c660b5bc9583b9bd1403f1a/Lib/concurrent/futures/process.py\n    if chunksize &lt; 1:\n        raise ValueError('chunksize must be &gt;= 1.')\n\n    results = super().map(\n        functools.partial(_process_chunk, function),\n        _get_chunks(*iterables, chunksize=chunksize),\n        timeout=timeout,\n    )\n\n    def _result_iterator(\n        iterable: Iterator[list[T]],\n    ) -&gt; Generator[T, None, None]:\n        for element in iterable:\n            element.reverse()\n            while element:\n                yield element.pop()\n\n    return _result_iterator(results)\n</code></pre>"},{"location":"api/executor/dag/#webs.executor.dag.DAGExecutor.shutdown","title":"shutdown()","text":"<pre><code>shutdown(\n    wait: bool = True, *, cancel_futures: bool = False\n) -&gt; None\n</code></pre> <p>Shutdown the executor.</p> <p>Parameters:</p> <ul> <li> <code>wait</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Wait on all pending futures to complete.</p> </li> <li> <code>cancel_futures</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Cancel all pending futures that the executor has not started running. Only used in Python 3.9 and later.</p> </li> </ul> Source code in <code>webs/executor/dag.py</code> <pre><code>def shutdown(\n    self,\n    wait: bool = True,\n    *,\n    cancel_futures: bool = False,\n) -&gt; None:\n    \"\"\"Shutdown the executor.\n\n    Args:\n        wait: Wait on all pending futures to complete.\n        cancel_futures: Cancel all pending futures that the executor\n            has not started running. Only used in Python 3.9 and later.\n    \"\"\"\n    if sys.version_info &gt;= (3, 9):  # pragma: &gt;=3.9 cover\n        self.executor.shutdown(wait=wait, cancel_futures=cancel_futures)\n    else:  # pragma: &lt;3.9 cover\n        self.executor.shutdown(wait=wait)\n</code></pre>"},{"location":"api/executor/globus/","title":"webs.executor.globus","text":"<code>webs/executor/globus.py</code>"},{"location":"api/executor/globus/#webs.executor.globus.GlobusComputeConfig","title":"GlobusComputeConfig","text":"<p>             Bases: <code>ExecutorConfig</code></p> <p>Globus Compute configuration.</p> <p>Attributes:</p> <ul> <li> <code>endpoint</code>             (<code>str</code>)         \u2013          <p>Globus Compute endpoint UUID.</p> </li> </ul>"},{"location":"api/executor/globus/#webs.executor.globus.GlobusComputeConfig.add_argument_group","title":"add_argument_group()  <code>classmethod</code>","text":"<pre><code>add_argument_group(\n    parser: ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True\n) -&gt; None\n</code></pre> <p>Add model fields as arguments of an argument group on the parser.</p> <p>Parameters:</p> <ul> <li> <code>parser</code>             (<code>ArgumentParser</code>)         \u2013          <p>Parser to add a new argument group to.</p> </li> <li> <code>argv</code>             (<code>Sequence[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional sequence of string arguments.</p> </li> <li> <code>required</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Mark arguments without defaults as required.</p> </li> </ul> Source code in <code>webs/config.py</code> <pre><code>@classmethod\ndef add_argument_group(\n    cls,\n    parser: argparse.ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Add model fields as arguments of an argument group on the parser.\n\n    Args:\n        parser: Parser to add a new argument group to.\n        argv: Optional sequence of string arguments.\n        required: Mark arguments without defaults as required.\n    \"\"\"\n    group = parser.add_argument_group(cls.__name__)\n    for field_name, field_info in cls.model_fields.items():\n        arg_name = field_name.replace('_', '-').lower()\n        group.add_argument(\n            f'--{arg_name}',\n            dest=field_name,\n            # type=field_info.annotation,\n            default=field_info.get_default(),\n            required=field_info.is_required() and required,\n            help=field_info.description,\n        )\n</code></pre>"},{"location":"api/executor/globus/#webs.executor.globus.GlobusComputeConfig.get_executor","title":"get_executor()","text":"<pre><code>get_executor() -&gt; Executor\n</code></pre> <p>Create an executor instance from the config.</p> Source code in <code>webs/executor/globus.py</code> <pre><code>def get_executor(self) -&gt; globus_compute_sdk.Executor:\n    \"\"\"Create an executor instance from the config.\"\"\"\n    return globus_compute_sdk.Executor(self.endpoint)\n</code></pre>"},{"location":"api/executor/python/","title":"webs.executor.python","text":"<code>webs/executor/python.py</code>"},{"location":"api/executor/python/#webs.executor.python.ThreadPoolConfig","title":"ThreadPoolConfig","text":"<p>             Bases: <code>ExecutorConfig</code></p> <p>Thread pool executor configuration.</p> <p>Attributes:</p> <ul> <li> <code>max_threads</code>             (<code>int</code>)         \u2013          <p>Maximum number of threads.</p> </li> </ul>"},{"location":"api/executor/python/#webs.executor.python.ThreadPoolConfig.add_argument_group","title":"add_argument_group()  <code>classmethod</code>","text":"<pre><code>add_argument_group(\n    parser: ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True\n) -&gt; None\n</code></pre> <p>Add model fields as arguments of an argument group on the parser.</p> <p>Parameters:</p> <ul> <li> <code>parser</code>             (<code>ArgumentParser</code>)         \u2013          <p>Parser to add a new argument group to.</p> </li> <li> <code>argv</code>             (<code>Sequence[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional sequence of string arguments.</p> </li> <li> <code>required</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Mark arguments without defaults as required.</p> </li> </ul> Source code in <code>webs/config.py</code> <pre><code>@classmethod\ndef add_argument_group(\n    cls,\n    parser: argparse.ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Add model fields as arguments of an argument group on the parser.\n\n    Args:\n        parser: Parser to add a new argument group to.\n        argv: Optional sequence of string arguments.\n        required: Mark arguments without defaults as required.\n    \"\"\"\n    group = parser.add_argument_group(cls.__name__)\n    for field_name, field_info in cls.model_fields.items():\n        arg_name = field_name.replace('_', '-').lower()\n        group.add_argument(\n            f'--{arg_name}',\n            dest=field_name,\n            # type=field_info.annotation,\n            default=field_info.get_default(),\n            required=field_info.is_required() and required,\n            help=field_info.description,\n        )\n</code></pre>"},{"location":"api/executor/python/#webs.executor.python.ThreadPoolConfig.get_executor","title":"get_executor()","text":"<pre><code>get_executor() -&gt; DAGExecutor\n</code></pre> <p>Create an executor instance from the config.</p> Source code in <code>webs/executor/python.py</code> <pre><code>def get_executor(self) -&gt; DAGExecutor:\n    \"\"\"Create an executor instance from the config.\"\"\"\n    return DAGExecutor(ThreadPoolExecutor(self.max_threads))\n</code></pre>"},{"location":"api/executor/workflow/","title":"webs.executor.workflow","text":"<code>webs/executor/workflow.py</code>"},{"location":"api/executor/workflow/#webs.executor.workflow.WorkflowTask","title":"WorkflowTask","text":"<pre><code>WorkflowTask(future: Future[T], task_id: UUID)\n</code></pre> <p>             Bases: <code>Generic[T]</code></p> <p>Workflow task information.</p> Source code in <code>webs/executor/workflow.py</code> <pre><code>def __init__(self, future: Future[T], task_id: uuid.UUID) -&gt; None:\n    self.future = future\n    self.task_id = task_id\n</code></pre>"},{"location":"api/executor/workflow/#webs.executor.workflow.WorkflowExecutor","title":"WorkflowExecutor","text":"<pre><code>WorkflowExecutor(compute_executor: Executor)\n</code></pre> <p>Workflow executor.</p> <p>Parameters:</p> <ul> <li> <code>compute_executor</code>             (<code>Executor</code>)         \u2013          <p>Compute executor.</p> </li> </ul> Source code in <code>webs/executor/workflow.py</code> <pre><code>def __init__(self, compute_executor: Executor) -&gt; None:\n    self.compute_executor = compute_executor\n</code></pre>"},{"location":"api/executor/workflow/#webs.executor.workflow.WorkflowExecutor.submit","title":"submit()","text":"<pre><code>submit(\n    function: Callable[P, T], /, *args: Any, **kwargs: Any\n) -&gt; WorkflowTask[T]\n</code></pre> <p>Schedule the callable to be executed.</p> <p>Parameters:</p> <ul> <li> <code>function</code>             (<code>Callable[P, T]</code>)         \u2013          <p>Callable to execute.</p> </li> <li> <code>args</code>             (<code>Any</code>, default:                 <code>()</code> )         \u2013          <p>Positional arguments.</p> </li> <li> <code>kwargs</code>             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>WorkflowTask[T]</code>         \u2013          <p>[<code>WorkflowTask</code>][webs.executor.workflow.WorkflowTask<code>] object             containing the [</code>Future`][concurrent.futures.Future] object             representing the result of the execution of the callable.</p> </li> </ul> Source code in <code>webs/executor/workflow.py</code> <pre><code>def submit(\n    self,\n    function: Callable[P, T],\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; WorkflowTask[T]:\n    \"\"\"Schedule the callable to be executed.\n\n    Args:\n        function: Callable to execute.\n        args: Positional arguments.\n        kwargs: Keyword arguments.\n\n    Returns:\n        [`WorkflowTask`][webs.executor.workflow.WorkflowTask`] object \\\n        containing the [`Future`][concurrent.futures.Future] object \\\n        representing the result of the execution of the callable.\n    \"\"\"\n    task_id = uuid.uuid4()\n    task = _TaskWrapper(function, task_id=task_id)\n    future = self.compute_executor.submit(task, *args, **kwargs)\n    return WorkflowTask(future, task_id)\n</code></pre>"},{"location":"api/executor/workflow/#webs.executor.workflow.WorkflowExecutor.map","title":"map()","text":"<pre><code>map(\n    function: Callable[P, T],\n    *iterables: Iterable[Any],\n    timeout: float | None = None,\n    chunksize: int = 1\n) -&gt; Iterator[T]\n</code></pre> <p>Map a function onto iterables of arguments.</p> Note <p>This method simply calls <code>self.compute_executor.map()</code>.</p> <p>Parameters:</p> <ul> <li> <code>function</code>             (<code>Callable[P, T]</code>)         \u2013          <p>A callable that will take as many arguments as there are passed iterables.</p> </li> <li> <code>iterables</code>             (<code>Iterable[Any]</code>, default:                 <code>()</code> )         \u2013          <p>Variable number of iterables.</p> </li> <li> <code>timeout</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>The maximum number of seconds to wait. If None, then there is no limit on the wait time.</p> </li> <li> <code>chunksize</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>If greater than one, the iterables will be chopped into chunks of size chunksize and submitted to the executor. If set to one, the items in the list will be sent one at a time.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[T]</code>         \u2013          <p>An iterator equivalent to: <code>map(func, *iterables)</code> but the calls             may be evaluated out-of-order.</p> </li> </ul> Source code in <code>webs/executor/workflow.py</code> <pre><code>def map(\n    self,\n    function: Callable[P, T],\n    *iterables: Iterable[Any],\n    timeout: float | None = None,\n    chunksize: int = 1,\n) -&gt; Iterator[T]:\n    \"\"\"Map a function onto iterables of arguments.\n\n    Note:\n        This method simply calls `self.compute_executor.map()`.\n\n    Args:\n        function: A callable that will take as many arguments as there are\n            passed iterables.\n        iterables: Variable number of iterables.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n        chunksize: If greater than one, the iterables will be chopped into\n            chunks of size chunksize and submitted to the executor. If set\n            to one, the items in the list will be sent one at a time.\n\n    Returns:\n        An iterator equivalent to: `map(func, *iterables)` but the calls \\\n        may be evaluated out-of-order.\n    \"\"\"\n    return self.compute_executor.map(\n        function,\n        *iterables,\n        timeout=timeout,\n        chunksize=chunksize,\n    )\n</code></pre>"},{"location":"api/executor/workflow/#webs.executor.workflow.WorkflowExecutor.shutdown","title":"shutdown()","text":"<pre><code>shutdown(\n    wait: bool = True, *, cancel_futures: bool = False\n) -&gt; None\n</code></pre> <p>Shutdown the executor.</p> <p>Parameters:</p> <ul> <li> <code>wait</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Wait on all pending futures to complete.</p> </li> <li> <code>cancel_futures</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Cancel all pending futures that the executor has not started running. Only used in Python 3.9 and later.</p> </li> </ul> Source code in <code>webs/executor/workflow.py</code> <pre><code>def shutdown(\n    self,\n    wait: bool = True,\n    *,\n    cancel_futures: bool = False,\n) -&gt; None:\n    \"\"\"Shutdown the executor.\n\n    Args:\n        wait: Wait on all pending futures to complete.\n        cancel_futures: Cancel all pending futures that the executor\n            has not started running. Only used in Python 3.9 and later.\n    \"\"\"\n    if sys.version_info &gt;= (3, 9):  # pragma: &gt;=3.9 cover\n        self.compute_executor.shutdown(\n            wait=wait,\n            cancel_futures=cancel_futures,\n        )\n    else:  # pragma: &lt;3.9 cover\n        self.compute_executor.shutdown(wait=wait)\n</code></pre>"},{"location":"api/run/","title":"webs.run","text":"<code>webs/run/__init__.py</code>"},{"location":"api/run/config/","title":"webs.run.config","text":"<code>webs/run/config.py</code>"},{"location":"api/run/config/#webs.run.config.RunConfig","title":"RunConfig","text":"<p>             Bases: <code>Config</code></p> <p>Run configuration.</p> <p>Attributes:</p> <ul> <li> <code>log_file_level</code>             (<code>Union[int, str]</code>)         \u2013          <p>Logging level for the log file.</p> </li> <li> <code>log_file_name</code>             (<code>Optional[str]</code>)         \u2013          <p>Logging file name. If <code>None</code>, only logging to <code>stdout</code> is used.</p> </li> <li> <code>log_level</code>             (<code>Union[int, str]</code>)         \u2013          <p>Logging level for <code>stdout</code>.</p> </li> <li> <code>run_dir</code>             (<code>str</code>)         \u2013          <p>Runtime directory.</p> </li> </ul>"},{"location":"api/run/config/#webs.run.config.RunConfig.add_argument_group","title":"add_argument_group()  <code>classmethod</code>","text":"<pre><code>add_argument_group(\n    parser: ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True\n) -&gt; None\n</code></pre> <p>Add model fields as arguments of an argument group on the parser.</p> <p>Parameters:</p> <ul> <li> <code>parser</code>             (<code>ArgumentParser</code>)         \u2013          <p>Parser to add a new argument group to.</p> </li> <li> <code>argv</code>             (<code>Sequence[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional sequence of string arguments.</p> </li> <li> <code>required</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Mark arguments without defaults as required.</p> </li> </ul> Source code in <code>webs/config.py</code> <pre><code>@classmethod\ndef add_argument_group(\n    cls,\n    parser: argparse.ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Add model fields as arguments of an argument group on the parser.\n\n    Args:\n        parser: Parser to add a new argument group to.\n        argv: Optional sequence of string arguments.\n        required: Mark arguments without defaults as required.\n    \"\"\"\n    group = parser.add_argument_group(cls.__name__)\n    for field_name, field_info in cls.model_fields.items():\n        arg_name = field_name.replace('_', '-').lower()\n        group.add_argument(\n            f'--{arg_name}',\n            dest=field_name,\n            # type=field_info.annotation,\n            default=field_info.get_default(),\n            required=field_info.is_required() and required,\n            help=field_info.description,\n        )\n</code></pre>"},{"location":"api/run/config/#webs.run.config.BenchmarkConfig","title":"BenchmarkConfig","text":"<p>             Bases: <code>Config</code></p> <p>Workflow benchmark configuration.</p> <p>Attributes:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the workflow to execute.</p> </li> <li> <code>timestamp</code>             (<code>datetime</code>)         \u2013          <p>Start time of the workflow.</p> </li> <li> <code>run</code>             (<code>RunConfig</code>)         \u2013          <p>Run configuration.</p> </li> <li> <code>workflow</code>             (<code>Config</code>)         \u2013          <p>Workflow configuration.</p> </li> </ul>"},{"location":"api/run/config/#webs.run.config.BenchmarkConfig.add_argument_group","title":"add_argument_group()  <code>classmethod</code>","text":"<pre><code>add_argument_group(\n    parser: ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True\n) -&gt; None\n</code></pre> <p>Add model fields as arguments of an argument group on the parser.</p> <p>Parameters:</p> <ul> <li> <code>parser</code>             (<code>ArgumentParser</code>)         \u2013          <p>Parser to add a new argument group to.</p> </li> <li> <code>argv</code>             (<code>Sequence[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional sequence of string arguments.</p> </li> <li> <code>required</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Mark arguments without defaults as required.</p> </li> </ul> Source code in <code>webs/config.py</code> <pre><code>@classmethod\ndef add_argument_group(\n    cls,\n    parser: argparse.ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Add model fields as arguments of an argument group on the parser.\n\n    Args:\n        parser: Parser to add a new argument group to.\n        argv: Optional sequence of string arguments.\n        required: Mark arguments without defaults as required.\n    \"\"\"\n    group = parser.add_argument_group(cls.__name__)\n    for field_name, field_info in cls.model_fields.items():\n        arg_name = field_name.replace('_', '-').lower()\n        group.add_argument(\n            f'--{arg_name}',\n            dest=field_name,\n            # type=field_info.annotation,\n            default=field_info.get_default(),\n            required=field_info.is_required() and required,\n            help=field_info.description,\n        )\n</code></pre>"},{"location":"api/run/config/#webs.run.config.BenchmarkConfig.get_log_file","title":"get_log_file()","text":"<pre><code>get_log_file() -&gt; Path | None\n</code></pre> <p>Get the log file if specified.</p> Source code in <code>webs/run/config.py</code> <pre><code>def get_log_file(self) -&gt; pathlib.Path | None:\n    \"\"\"Get the log file if specified.\"\"\"\n    log_file_name = self.run.log_file_name\n    if log_file_name is None:\n        return None\n    return self.get_run_dir() / log_file_name\n</code></pre>"},{"location":"api/run/config/#webs.run.config.BenchmarkConfig.get_run_dir","title":"get_run_dir()","text":"<pre><code>get_run_dir() -&gt; Path\n</code></pre> <p>Create and return the path to the run directory.</p> Source code in <code>webs/run/config.py</code> <pre><code>def get_run_dir(self) -&gt; pathlib.Path:\n    \"\"\"Create and return the path to the run directory.\"\"\"\n    timestamp = self.timestamp.strftime('%Y-%m-%d-%H-%M-%S')\n    run_dir = pathlib.Path(\n        self.run.run_dir.format(name=self.name, timestamp=timestamp),\n    )\n    run_dir.mkdir(parents=True, exist_ok=True)\n    return run_dir\n</code></pre>"},{"location":"api/run/main/","title":"webs.run.main","text":"<code>webs/run/main.py</code>"},{"location":"api/run/main/#webs.run.main.parse_args_to_config","title":"parse_args_to_config()","text":"<pre><code>parse_args_to_config(\n    argv: Sequence[str],\n) -&gt; BenchmarkConfig\n</code></pre> <p>Parse sequence of string arguments into a config.</p> <p>Parameters:</p> <ul> <li> <code>argv</code>             (<code>Sequence[str]</code>)         \u2013          <p>Sequence of string arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BenchmarkConfig</code>         \u2013          <p>Configuration.</p> </li> </ul> Source code in <code>webs/run/main.py</code> <pre><code>def parse_args_to_config(argv: Sequence[str]) -&gt; BenchmarkConfig:\n    \"\"\"Parse sequence of string arguments into a config.\n\n    Args:\n        argv: Sequence of string arguments.\n\n    Returns:\n        Configuration.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description='Workflow benchmark suite.',\n        prog='python -m webs.run',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n    )\n\n    subparsers = parser.add_subparsers(\n        title='Workflows',\n        dest='name',\n        required=True,\n        help='workflow to execute',\n    )\n\n    workflows = get_registered()\n    workflow_names = sorted(workflows.keys())\n    for workflow_name in workflow_names:\n        workflow = workflows[workflow_name]\n        subparser = subparsers.add_parser(workflow.name)\n\n        RunConfig.add_argument_group(subparser, argv=argv, required=True)\n        ExecutorChoicesConfig.add_argument_group(\n            subparser,\n            argv=argv,\n            required=True,\n        )\n        workflow.config_type.add_argument_group(\n            subparser,\n            argv=argv,\n            required=True,\n        )\n\n    args = parser.parse_args(argv)\n    options = vars(args)\n\n    workflow_name = options['name']\n    executor_config = get_executor_config(**options)\n    run_config = RunConfig(**options)\n    workflow_config = workflows[workflow_name].config_type(**options)\n\n    return BenchmarkConfig(\n        name=workflow_name,\n        timestamp=datetime.now(),\n        executor=executor_config,\n        run=run_config,\n        workflow=workflow_config,\n    )\n</code></pre>"},{"location":"api/run/main/#webs.run.main.run","title":"run()","text":"<pre><code>run(config: BenchmarkConfig) -&gt; None\n</code></pre> <p>Run a workflow using the configuration.</p> Source code in <code>webs/run/main.py</code> <pre><code>def run(config: BenchmarkConfig) -&gt; None:\n    \"\"\"Run a workflow using the configuration.\"\"\"\n    start = time.perf_counter()\n    logger.log(RUN_LOG_LEVEL, f'Starting workflow (name={config.name})')\n    logger.log(RUN_LOG_LEVEL, config)\n\n    compute_executor = config.executor.get_executor()\n    workflow = get_registered()[config.name].from_config(config.workflow)\n\n    with workflow, WorkflowExecutor(compute_executor) as executor:\n        workflow.run(executor=executor, run_dir=config.get_run_dir())\n\n    runtime = time.perf_counter() - start\n    logger.log(\n        RUN_LOG_LEVEL,\n        f'Finished workflow (name={config.name}, runtime={runtime:.2f}s)',\n    )\n</code></pre>"},{"location":"api/wf/","title":"webs.wf","text":"<code>webs/wf/__init__.py</code>"},{"location":"api/wf/synthetic/","title":"webs.wf.synthetic","text":"<code>webs/wf/synthetic/__init__.py</code>"},{"location":"api/wf/synthetic/config/","title":"webs.wf.synthetic.config","text":"<code>webs/wf/synthetic/config.py</code>"},{"location":"api/wf/synthetic/config/#webs.wf.synthetic.config.SyntheticWorkflowConfig","title":"SyntheticWorkflowConfig","text":"<p>             Bases: <code>Config</code></p> <p>Synthetic workflow configuration.</p>"},{"location":"api/wf/synthetic/config/#webs.wf.synthetic.config.SyntheticWorkflowConfig.add_argument_group","title":"add_argument_group()  <code>classmethod</code>","text":"<pre><code>add_argument_group(\n    parser: ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True\n) -&gt; None\n</code></pre> <p>Add model fields as arguments of an argument group on the parser.</p> <p>Parameters:</p> <ul> <li> <code>parser</code>             (<code>ArgumentParser</code>)         \u2013          <p>Parser to add a new argument group to.</p> </li> <li> <code>argv</code>             (<code>Sequence[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional sequence of string arguments.</p> </li> <li> <code>required</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Mark arguments without defaults as required.</p> </li> </ul> Source code in <code>webs/config.py</code> <pre><code>@classmethod\ndef add_argument_group(\n    cls,\n    parser: argparse.ArgumentParser,\n    *,\n    argv: Sequence[str] | None = None,\n    required: bool = True,\n) -&gt; None:\n    \"\"\"Add model fields as arguments of an argument group on the parser.\n\n    Args:\n        parser: Parser to add a new argument group to.\n        argv: Optional sequence of string arguments.\n        required: Mark arguments without defaults as required.\n    \"\"\"\n    group = parser.add_argument_group(cls.__name__)\n    for field_name, field_info in cls.model_fields.items():\n        arg_name = field_name.replace('_', '-').lower()\n        group.add_argument(\n            f'--{arg_name}',\n            dest=field_name,\n            # type=field_info.annotation,\n            default=field_info.get_default(),\n            required=field_info.is_required() and required,\n            help=field_info.description,\n        )\n</code></pre>"},{"location":"api/wf/synthetic/workflow/","title":"webs.wf.synthetic.workflow","text":"<code>webs/wf/synthetic/workflow.py</code>"},{"location":"api/wf/synthetic/workflow/#webs.wf.synthetic.workflow.SyntheticWorkflow","title":"SyntheticWorkflow","text":"<pre><code>SyntheticWorkflow(config: SyntheticWorkflowConfig)\n</code></pre> <p>             Bases: <code>ContextManagerAddIn</code></p> <p>Synthetic workflow.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>SyntheticWorkflowConfig</code>)         \u2013          <p>Workflow configuration.</p> </li> </ul> Source code in <code>webs/wf/synthetic/workflow.py</code> <pre><code>def __init__(self, config: SyntheticWorkflowConfig) -&gt; None:\n    self.config = config\n    super().__init__()\n</code></pre>"},{"location":"api/wf/synthetic/workflow/#webs.wf.synthetic.workflow.SyntheticWorkflow.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: SyntheticWorkflowConfig) -&gt; Self\n</code></pre> <p>Initialize a workflow from a config.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>SyntheticWorkflowConfig</code>)         \u2013          <p>Workflow configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Workflow.</p> </li> </ul> Source code in <code>webs/wf/synthetic/workflow.py</code> <pre><code>@classmethod\ndef from_config(cls, config: SyntheticWorkflowConfig) -&gt; Self:\n    \"\"\"Initialize a workflow from a config.\n\n    Args:\n        config: Workflow configuration.\n\n    Returns:\n        Workflow.\n    \"\"\"\n    return cls(config)\n</code></pre>"},{"location":"api/wf/synthetic/workflow/#webs.wf.synthetic.workflow.SyntheticWorkflow.run","title":"run()","text":"<pre><code>run(executor: WorkflowExecutor, run_dir: Path) -&gt; None\n</code></pre> <p>Run the workflow.</p> <p>Parameters:</p> <ul> <li> <code>executor</code>             (<code>WorkflowExecutor</code>)         \u2013          <p>Workflow task executor.</p> </li> <li> <code>run_dir</code>             (<code>Path</code>)         \u2013          <p>Run directory.</p> </li> </ul> Source code in <code>webs/wf/synthetic/workflow.py</code> <pre><code>def run(self, executor: WorkflowExecutor, run_dir: pathlib.Path) -&gt; None:\n    \"\"\"Run the workflow.\n\n    Args:\n        executor: Workflow task executor.\n        run_dir: Run directory.\n    \"\"\"\n    input_data: bytes | Future[bytes] = randbytes(\n        self.config.task_data_bytes,\n    )\n    tasks: dict[Future[bytes], WorkflowTask[bytes]] = {}\n\n    for i in range(self.config.task_count):\n        task = executor.submit(\n            noop_task,\n            input_data,\n            output_size=self.config.task_data_bytes,\n            sleep=self.config.task_sleep,\n        )\n        input_data = task.future\n        tasks[task.future] = task\n        logger.log(\n            WORK_LOG_LEVEL,\n            f'Submitted task {i+1}/{self.config.task_count} '\n            f'(task_id={task.task_id})',\n        )\n\n    for i, future in enumerate(as_completed(tasks.keys())):\n        task = tasks[future]\n        logger.log(\n            WORK_LOG_LEVEL,\n            f'Received task {i+1}/{self.config.task_count} '\n            f'(task_id={task.task_id})',\n        )\n</code></pre>"},{"location":"api/wf/synthetic/workflow/#webs.wf.synthetic.workflow.noop_task","title":"noop_task()","text":"<pre><code>noop_task(\n    data: bytes, output_size: int, sleep: float\n) -&gt; bytes\n</code></pre> <p>No-op sleep task.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>bytes</code>)         \u2013          <p>Input byte string.</p> </li> <li> <code>output_size</code>             (<code>int</code>)         \u2013          <p>Size in bytes of output byte-string.</p> </li> <li> <code>sleep</code>             (<code>float</code>)         \u2013          <p>Minimum runtime of the task. Time required to generate the output data will be subtracted from this sleep time.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>         \u2013          <p>Byte-string of length <code>output_size</code>.</p> </li> </ul> Source code in <code>webs/wf/synthetic/workflow.py</code> <pre><code>def noop_task(data: bytes, output_size: int, sleep: float) -&gt; bytes:\n    \"\"\"No-op sleep task.\n\n    Args:\n        data: Input byte string.\n        output_size: Size in bytes of output byte-string.\n        sleep: Minimum runtime of the task. Time required to generate the\n            output data will be subtracted from this sleep time.\n\n    Returns:\n        Byte-string of length `output_size`.\n    \"\"\"\n    start = time.perf_counter_ns()\n    result = randbytes(output_size)\n    elapsed = (time.perf_counter_ns() - start) / 1e9\n\n    # Remove elapsed time for generating result from remaining\n    # sleep time.\n    time.sleep(max(0, sleep - elapsed))\n    return result\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#getting-started-for-local-development","title":"Getting Started for Local Development","text":"<p>We recommend using Tox to setup the development environment. This will create a new virtual environment with all of the required packages installed and WEBS installed in editable mode with the necessary extras options.</p> <pre><code>$ git clone https://github.com/proxystore/webs\n$ cd foobar\n$ tox --devenv venv -e py311\n$ . venv/bin/activate\n</code></pre> <p>Warning</p> <p>Running Tox in a Conda environment is possible but it may conflict with Tox's ability to find the correct Python versions. E.g., if your Conda environment is Python 3.11, running <code>$ tox -e p310</code> may still use Python 3.11.</p> <p>To install manually: <pre><code>$ git clone https://github.com/proxystore/webs\n$ cd webs\n$ python -m venv venv\n$ . venv/bin/activate\n$ pip install -e .[dev,docs]\n</code></pre></p>"},{"location":"contributing/#continuous-integration","title":"Continuous Integration","text":"<p>FooBar uses pre-commit and Tox for continuous integration (test, linting, etc.).</p>"},{"location":"contributing/#linting-and-type-checking-pre-commit","title":"Linting and Type Checking (pre-commit)","text":"<p>To use pre-commit, install the hook and then run against files.</p> <pre><code>$ pre-commit install\n$ pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#tests-tox","title":"Tests (tox)","text":"<p>The entire CI workflow can be run with <code>$ tox</code>. This will test against multiple versions of Python and can be slow.</p> <p>Module-level unit-test are located in the <code>tests/</code> directory and its structure is intended to match that of <code>foobar/</code>. E.g. the tests for <code>webs/x/y.py</code> are located in <code>tests/x/y_test.py</code>; however, additional test files can be added as needed. Tests should be narrowly focused and target a single aspect of the code's functionality, tests should not test internal implementation details of the code, and tests should not be dependent on the order in which they are run.</p> <p>Code that is useful for building tests but is not a test itself belongs in the <code>testing/</code> directory.</p> <pre><code># Run all tests in tests/\n$ tox -e py39\n# Run a specific test\n$ tox -e py39 -- tests/x/y_test.py::test_z\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<p>If code changes require an update to the documentation (e.g., for function signature changes, new modules, etc.), the documentation can be built using MKDocs.</p> <pre><code># Manually\n$ pip install -e .[docs]\n$ mkdocs build --strict  # Build only to site/index.html\n$ mkdocs serve           # Serve locally\n\n# With tox (will only build, does not serve)\n$ tox -e docs\n</code></pre> <p>Docstrings are automatically generated, but it is recommended to check the generated docstrings to make sure details/links/etc. are correct.</p>"},{"location":"contributing/issues-pull-requests/","title":"Issues and Pull Requests","text":""},{"location":"contributing/issues-pull-requests/#issues","title":"Issues","text":"<p>Issue Tracker</p> <p>We use GitHub issues to report problems, request and track changes, and discuss future ideas. If you open an issue for a specific problem, please follow the template guides.</p>"},{"location":"contributing/issues-pull-requests/#pull-requests","title":"Pull Requests","text":"<p>We use the standard GitHub contribution cycle where all contributions are made via pull requests (including code owners!).</p> <ol> <li>Fork the repository and clone to your local machine.</li> <li> <p>Create local changes.</p> <ul> <li>Changes should conform to the style and testing guidelines, referenced   above.</li> <li>Preferred commit message format (source):<ul> <li>separate subject from body with a blank line,</li> <li>limit subject line to 50 characters,</li> <li>capitalize first word of subject line,</li> <li>do not end the subject line with a period,</li> <li>use the imperative mood for subject lines,</li> <li>include related issue numbers at end of subject line,</li> <li>wrap body at 72 characters, and</li> <li>use the body to explain what/why rather than how.</li> <li>Example: <code>Fix concurrency bug in Store (#42)</code></li> </ul> </li> </ul> </li> <li> <p>Push commits to your fork.</p> <ul> <li>Please squash commits fixing mistakes to keep the git history clean.   For example, if commit \"b\" follows commit \"a\" and only fixes a small typo   from \"a\", please squash \"a\" and \"b\" into a single, correct commit.   This keeps the commit history readable and easier to search through when   debugging (e.g., git blame/bisect).</li> </ul> </li> <li>Open a pull request in this repository.<ul> <li>The pull request should include a description of the motivation for the   PR and included changes. A PR template is provided to guide this process.</li> </ul> </li> </ol>"},{"location":"contributing/releases/","title":"Releases","text":""},{"location":"contributing/releases/#release-timeline","title":"Release Timeline","text":"<p>Releases are created on an as-needed basis. Milestones are the Issue Tracker are used to track features to be included in upcoming releases.</p>"},{"location":"contributing/releases/#creating-releases","title":"Creating Releases","text":"<ol> <li>Choose the next version number, referred to as <code>{VERSION}</code> for the    rest of the instructions. Versioning follows semver    (<code>major.minor.patch</code>) with optional PEP-440    pre-release/post-release/dev-release segments. Major/minor/patch numbers    start at 0 and pre-release/post-release/dev-release segments start at 1.</li> <li>Update the version in <code>pyproject.toml</code> to <code>{VERSION}</code>.</li> <li>Commit and merge the version updates/changelogs into main.</li> <li>Tag the release commit and push (typically this is the commit updating the    version numbers).    <pre><code>$ git tag -s v{VERSION} -m \"FooBar v{VERSION}\"\n$ git push origin v{VERSION}\n</code></pre>    Note the version number is prepended by \"v\" for the tags so we can    distinguish release tags from non-release tags.</li> <li>Create a new release on GitHub using the tag. The title should be    <code>FooBar v{VERSION}</code>.</li> <li>Official release:<ol> <li>Use the \"Generate release notes\" option and set the previous tag as the previous official release tag. E.g., for <code>v0.4.1</code>, the previous release tag should be <code>v0.4.0</code> and NOT <code>v0.4.1a1</code>.</li> <li>Add an \"Upgrade Steps\" section at the top (see previous releases for examples).</li> <li>Review the generated notes and edit as needed. PRs are organized by tag, but some PRs will be missing tags and need to be moved from the \"Other Changes\" section to the correct section.</li> <li>Select \"Set as the latest release.\"</li> </ol> </li> <li>Unofficial release: (alpha/dev builds)<ol> <li>Do NOT generate release notes. The body can be along the lines of \"Development pre-prelease for <code>V{VERSION}</code>.\"</li> <li>Leave the previous tag as \"auto.\"</li> <li>Select \"Set as a pre-release.\"</li> </ol> </li> </ol>"},{"location":"contributing/style-guide/","title":"Style Guide","text":"<p>The Python code and docstring format mostly follows Google's Python Style Guide, but the pre-commit config is the authoritative source for code format compliance.</p> <p>Nits:</p> <ul> <li>Avoid imports in <code>__init__.py</code> (reduces the likelihood of circular imports).</li> <li>Prefer pure functions where possible.</li> <li>Define all class attributes inside <code>__init__</code> so all attributes are visible   in one place. Attributes that are defined later can be set as <code>None</code>   as a placeholder.</li> <li>Prefer f-strings (<code>f'name: {name}</code>) over string format   (<code>'name: {}'.format(name)</code>). Never use the <code>%</code> operator.</li> <li>Prefer typing.NamedTuple over collections.namedtuple.</li> <li>Use lower-case and no punctuation for log messages, but use upper-case and   punctuation for exception values.   <pre><code>logger.info(f'new connection opened to {address}')\nraise ValueError('Name must contain alphanumeric characters only.')\n</code></pre></li> <li>Document all exceptions that may be raised by a function in the docstring.</li> </ul>"},{"location":"guides/","title":"Guides","text":"<ul> <li>Creating Workflows</li> </ul>"},{"location":"guides/creating-workflows/","title":"Creating Workflows","text":"<p>Todo</p> <p>This guide is underdevelopment.</p>"}]}